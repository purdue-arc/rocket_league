#!/usr/bin/env python
"""Very simple node to estimate odometry from poses over time.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# Python
from math import sin, cos
from scipy import signal

# ROS
import rospy
from geometry_msgs.msg import PoseWithCovarianceStamped
from nav_msgs.msg import Odometry
from tf.transformations import euler_from_quaternion

class Filter(object):
    """Low pass filter."""
    def __init__(self, order, fc, fs=30.0):
        f_norm = 2*fc/fs
        self.top, self.bot = signal.butter(order, f_norm)
        self.state = signal.lfilter_zi(self.top, self.bot)

    def filter(self, x):
        """Add a new measurement."""
        y, self.state = signal.lfilter(self.top, self.bot, [x], zi=self.state)
        return y

class OdomEstimator(object):
    """Simple node that derives velocity from position."""
    def __init__(self):
        rospy.init_node('pose_estimation')

        # variables to store previous pose and timestamp
        self.last_pose = None
        self.last_time = None

        F_SAMPLE = rospy.get_param('~sampling_frequency', 30.0)
        self.x_filter = Filter(
            rospy.get_param('~filters/x/order', 1),
            rospy.get_param('~filters/x/cutoff', 3.0),
            fs=F_SAMPLE)
        self.y_filter = Filter(
            rospy.get_param('~filters/y/order', 1),
            rospy.get_param('~filters/y/cutoff', 3.0),
            fs=F_SAMPLE)
        self.theta_filter = Filter(
            rospy.get_param('~filters/theta/order', 1),
            rospy.get_param('~filters/theta/cutoff', 3.0),
            fs=F_SAMPLE)

        # params
        self.BASE_LINK = rospy.get_param('~base_link', 'base_link')
        self.BUFFER_SIZE = rospy.get_param('~buffer_size', 3)

        # publishers
        self.odom_pub = rospy.Publisher('odom', Odometry, queue_size=1)

        # subscribers
        rospy.Subscriber('pose', PoseWithCovarianceStamped, self.pose_cb)

        rospy.spin()

    def pose_cb(self, pose_msg):
        """Callback for detection messages."""
        # extract bot position & angle
        x = pose_msg.pose.pose.position.x
        y = pose_msg.pose.pose.position.y
        quat = (pose_msg.pose.pose.orientation.x,
                pose_msg.pose.pose.orientation.y,
                pose_msg.pose.pose.orientation.z,
                pose_msg.pose.pose.orientation.w)
        (__, __, theta) = euler_from_quaternion(quat)

        # publish odom if there is a previous timestamp
        if self.last_time is not None:
            # create new odometry message
            odom_msg = Odometry()
            odom_msg.header = pose_msg.header
            odom_msg.child_frame_id = self.BASE_LINK
            odom_msg.pose = pose_msg.pose

            # deltas in world frame
            dx = x - self.last_pose[0]
            dy = y - self.last_pose[1]
            d_theta = theta - self.last_pose[2]

            # velocities in world frame
            dt = (pose_msg.header.stamp - self.last_time).to_sec()
            if dt == 0:
                return

            v_theta = d_theta / dt

            # velocites in local frame
            vx_local =  dx*cos(theta) + dy*sin(theta)
            vy_local = -dx*sin(theta) + dy*cos(theta)

            # add to low pass filter
            vx_local_filtered = self.x_filter.filter(vx_local)
            vy_local_filtered = self.y_filter.filter(vy_local)
            v_theta_local_filtered = self.theta_filter.filter(v_theta)

            # set odom velocities
            odom_msg.twist.twist.linear.x = vx_local_filtered
            odom_msg.twist.twist.linear.y = vy_local_filtered
            odom_msg.twist.twist.angular.z = v_theta_local_filtered

            # publish odom message
            self.odom_pub.publish(odom_msg)

        # reset last pose and timestamp
        self.last_time = pose_msg.header.stamp
        self.last_pose = (x, y, theta)

if __name__ == "__main__":
    OdomEstimator()

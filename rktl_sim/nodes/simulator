#!/usr/bin/env python3
"""Node to run the simulator with ROS bindings.
License:
  BSD 3-Clause License
  Copyright (c) 2023, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# 3rd party modules
from geometry_msgs.msg import PoseWithCovarianceStamped
from nav_msgs.msg import Odometry
import os
import rospy
from std_srvs.srv import Empty, EmptyResponse
from threading import Lock
from enum import Enum

# Local library
import simulator
from rktl_sim.srv import CreateCar, CreateCarResponse, DeleteCar, DeleteCarResponse
from rktl_msgs.msg import MatchStatus, ControlCommand, ControlEffort

class SimulatorMode(Enum):
    IDEAL = 1
    REALISTIC = 2

class Simulator(object):
    """ROS wrapper for the simulator."""

    def __init__(self):
        rospy.init_node('simulator')

        mode = rospy.get_param('~mode')
        if mode == 'ideal':
            self.mode = SimulatorMode.IDEAL
        elif mode == 'realistic':
            self.mode = SimulatorMode.REALISTIC
        else:
            rospy.signal_shutdown('unknown sim mode set "{}"'.format(mode))

        render_enabled = rospy.get_param('~render', False)
        rate = rospy.Rate(rospy.get_param('~rate', 30))
        self.frame_id = rospy.get_param('~frame_id', 'map')
        self.timeout = rospy.get_param('~timeout', 10)

        # Setting up field
        fw = rospy.get_param('/field/width')
        fl = rospy.get_param('/field/length')
        wt = rospy.get_param('/field/wall_thickness')
        spawn_height = rospy.get_param('~spawn_height', 0.06)

        # Setup bounds for spawning car and ball
        spawn_bounds = [[-(fl/2) + (2 * wt), (fl/2) - (2 * wt)],
                        [-(fw/2) + (2 * wt), (fw/2) - (2 * wt)],
                        [spawn_height, spawn_height]]

        urdf_paths = rospy.get_param('~urdf')
        for path in urdf_paths.values():
            self.check_urdf(path)

        # Setup simulator properties
        props = {
            'engine': rospy.get_param('~engine', None),
            'dynamics': rospy.get_param('~dynamics', None),
        }

        # Creating physics simulator
        self.sim = simulator.Sim(props, urdf_paths, spawn_bounds, render_enabled)

        # Setting sensor noise
        sensor_noise = rospy.get_param('~sensor_noise', None)
        ball_noise = None
        car_noise = None
        if sensor_noise is not None and self.mode == SimulatorMode.REALISTIC:
            ball_noise = sensor_noise.get('ball', None)
            car_noise = sensor_noise.get('car', None)
        self.car_noise = car_noise

        # Creating the ball
        ball_init_pose = rospy.get_param('~ball/init_pose', None)
        ball_init_speed = rospy.get_param('~ball/init_speed', None)

        self.sim.create_ball('ball', init_pose=ball_init_pose,
            init_speed=ball_init_speed, noise=ball_noise)
        
        if self.mode == SimulatorMode.REALISTIC:
            self.ball_pose_pub = rospy.Publisher('/ball/pose_sync_early',
                PoseWithCovarianceStamped, queue_size=1)
            self.ball_odom_pub = rospy.Publisher('/ball/odom_truth',
                Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.ball_odom_pub = rospy.Publisher('/ball/odom',
                Odometry, queue_size=1)

        # Creating cars
        car_properties = {}
        car_properties['length'] = rospy.get_param('/cars/length')
        car_properties['max_speed'] = rospy.get_param('/cars/throttle/max_speed')
        car_properties['throttle_tau'] = rospy.get_param('/cars/throttle/tau')
        car_properties['steering_throw'] = rospy.get_param('/cars/steering/max_throw')
        car_properties['steering_rate'] = rospy.get_param('/cars/steering/rate')
        car_properties['simulate_effort'] = (self.mode == SimulatorMode.REALISTIC)
        self.car_properties = car_properties
        
        self.car_ids = {}
        self.car_pose_pubs = {}
        self.car_odom_pubs = {}
        self.car_effort_subs = {}
        self.car_cmd_subs = {}
        car_configs = rospy.get_param('~cars', [])
        for car_config in car_configs:
            init_pose = None
            if 'init_pose' in car_config:
                init_pose = car_config['init_pose']

            if 'name' not in car_config:
                rospy.signal_shutdown('no "name" set for car config in sim')
            car_name = car_config['name']

            self.car_ids[car_name] = self.sim.create_car(
                'car', init_pose=init_pose, noise=car_noise, car_props=car_properties)

            car_id = self.car_ids[car_name]
            self.car_effort_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/effort', ControlEffort,
                self.effort_cb, callback_args=car_id)
            self.car_cmd_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/command', ControlCommand,
                self.cmd_cb, callback_args=car_id)
            
            if self.mode == SimulatorMode.REALISTIC:
                self.car_pose_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/pose_sync_early',
                    PoseWithCovarianceStamped, queue_size=1)
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom_truth', Odometry, queue_size=1)
            elif self.mode == SimulatorMode.IDEAL:
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom', Odometry, queue_size=1)

        # Node data
        self.cmd_lock = Lock()
        self.reset_lock = Lock()
        self.last_time = None

        # Publishers
        self.status_pub = rospy.Publisher(
            'match_status', MatchStatus, queue_size=1)

        # Services
        rospy.Service('sim_reset', Empty, self.reset_cb)
        rospy.Service('sim_create_car', CreateCar, self.create_car_cb)
        rospy.Service('sim_delete_car', DeleteCar, self.delete_car_cb)

        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def check_urdf(self, param):
        """Validates that a URDF exists, then returns path"""
        if param is None:
            rospy.signal_shutdown('no urdf path set for "{}"'.format(param))

        i = 0
        while not os.path.isfile(param) and i < 5:
            rospy.sleep(0.1) # Wait for xacro build
            i += 1
        
        if not os.path.isfile(param):
            rospy.signal_shutdown(
                'no urdf file exists at path {}'.format(param))

    def effort_cb(self, effort_msg, car_id):
        """Sets a car's effort (overwrites commands)"""
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
            (effort_msg.throttle, effort_msg.steering))
        self.cmd_lock.release()

    def cmd_cb(self, cmd_msg, car_id):
        """Sets a car's command (overwrites efforts)"""
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
            (cmd_msg.velocity, cmd_msg.curvature))
        self.cmd_lock.release()

    def create_car_cb(self, req):
        """Adds a new car to the simulator"""
        self.reset_lock.acquire()
        if req.name in self.car_ids:
            return CreateCarResponse(False)

        init_pose = None
        if req.reset_to_random_pose is False:
            init_pose = {
                "pos": [req.init_pos.x,
                        req.init_pos.y, 
                        req.init_pos.z],
                "orient": [0.0, 0.0, req.init_yaw],
            }

        self.car_ids[req.name] = self.sim.create_car(
            'car', init_pose, noise=self.car_noise, props=self.car_properties) 

        car_id = self.car_ids[req.name]
        self.car_effort_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/effort', ControlEffort,
            self.effort_cb, callback_args=car_id)
        self.car_cmd_subs[req.name] =  rospy.Subscriber(
            f'/cars/{req.name}/command', ControlCommand,
            self.cmd_cb, callback_args=car_id)
        
        if self.mode == SimulatorMode.REALISTIC:
            self.car_pose_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/pose_sync_early',
                PoseWithCovarianceStamped, queue_size=1)
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom_truth', Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom', Odometry, queue_size=1)

        self.reset_lock.release()
        return CreateCarResponse(True)

    def delete_car_cb(self, req):
        """Removes a car from the simulator"""
        self.reset_lock.acquire()
        if req.name not in self.car_ids:
            return DeleteCarResponse(False)

        # Delete all related pubs and subs
        if req.name in self.car_effort_subs:
            self.car_effort_subs[req.name].unregister()
            del self.car_effort_subs[req.name]
        if req.name in self.car_cmd_subs:
            self.car_cmd_subs[req.name].unregister()
            del self.car_cmd_subs[req.name]
        if req.name in self.car_odom_pubs:
            self.car_odom_pubs[req.name].unregister()
            del self.car_odom_pubs[req.name]
        if req.name in self.car_pose_pubs:
            self.car_pose_pubs[req.name].unregister()
            del self.car_pose_pubs[req.name]
        
        # Delete the car's body from pybullet
        res = self.sim.delete_car(self.car_ids[req.name])
        del self.car_ids[req.name]
        
        self.reset_lock.release()
        return DeleteCarResponse(res)

    def reset_cb(self, _):
        """Resets simulator"""
        self.reset_lock.acquire()
        self.sim.reset()
        self.car_cmd = (0.0, 0.0)
        self.last_time = None
        self.reset_lock.release()
        return EmptyResponse()

    def loop_once(self):
        """Main loop"""
        self.reset_lock.acquire()
        now = rospy.Time.now()
        if self.last_time is not None and self.last_time != now:
            # Iterate sim one step
            delta_t = (now - self.last_time).to_sec()
            self.sim.step(delta_t)

            # Publish game status
            status = MatchStatus()
            if self.sim.scored:
                if self.sim.winner == "A":
                    status.status = MatchStatus.VICTORY_TEAM_A
                elif self.sim.winner == "B":
                    status.status = MatchStatus.VICTORY_TEAM_B
            else:
                status.status = MatchStatus.ONGOING
            self.status_pub.publish(status)

            # Publish pose and odometry data
            if self.mode == SimulatorMode.REALISTIC:
                ball_msg = PoseWithCovarianceStamped()
                ball_msg.header.stamp = now
                ball_msg.header.frame_id = self.frame_id
                ball_pos, ball_quat = self.sim.get_ball_pose(add_noise=True)
                ball_msg.pose.pose.position.x = ball_pos[0]
                ball_msg.pose.pose.position.y = ball_pos[1]
                ball_msg.pose.pose.position.z = ball_pos[2]
                ball_msg.pose.pose.orientation.x = ball_quat[0]
                ball_msg.pose.pose.orientation.y = ball_quat[1]
                ball_msg.pose.pose.orientation.z = ball_quat[2]
                ball_msg.pose.pose.orientation.w = ball_quat[3]
                self.ball_pose_pub.publish(ball_msg)

                for car_name in self.car_ids:
                    car_msg = PoseWithCovarianceStamped()
                    car_msg.header.stamp = now
                    car_msg.header.frame_id = self.frame_id
                    car_pos, car_quat = self.sim.get_car_pose(
                        self.car_ids[car_name], add_noise=True)
                    car_msg.pose.pose.position.x = car_pos[0]
                    car_msg.pose.pose.position.y = car_pos[1]
                    car_msg.pose.pose.position.z = car_pos[2]
                    car_msg.pose.pose.orientation.x = car_quat[0]
                    car_msg.pose.pose.orientation.y = car_quat[1]
                    car_msg.pose.pose.orientation.z = car_quat[2]
                    car_msg.pose.pose.orientation.w = car_quat[3]
                    self.car_pose_pubs[car_name].publish(car_msg)

            ball_msg = Odometry()
            ball_msg.header.stamp = now
            ball_msg.header.frame_id = self.frame_id
            ball_pos, ball_quat = self.sim.get_ball_pose()
            ball_msg.pose.pose.position.x = ball_pos[0]
            ball_msg.pose.pose.position.y = ball_pos[1]
            ball_msg.pose.pose.position.z = ball_pos[2]
            ball_msg.pose.pose.orientation.x = ball_quat[0]
            ball_msg.pose.pose.orientation.y = ball_quat[1]
            ball_msg.pose.pose.orientation.z = ball_quat[2]
            ball_msg.pose.pose.orientation.w = ball_quat[3]
            ball_linear, ball_angular = self.sim.get_ball_velocity()
            ball_msg.twist.twist.linear.x = ball_linear[0]
            ball_msg.twist.twist.linear.y = ball_linear[1]
            ball_msg.twist.twist.linear.z = ball_linear[2]
            ball_msg.twist.twist.angular.x = ball_angular[0]
            ball_msg.twist.twist.angular.y = ball_angular[1]
            ball_msg.twist.twist.angular.z = ball_angular[2]
            self.ball_odom_pub.publish(ball_msg)

            for car_name in self.car_ids:
                car_msg = Odometry()
                car_msg.header.stamp = now
                car_msg.header.frame_id = self.frame_id
                car_pos, car_quat = self.sim.get_car_pose(
                    self.car_ids[car_name])
                car_msg.pose.pose.position.x = car_pos[0]
                car_msg.pose.pose.position.y = car_pos[1]
                car_msg.pose.pose.position.z = car_pos[2]
                car_msg.pose.pose.orientation.x = car_quat[0]
                car_msg.pose.pose.orientation.y = car_quat[1]
                car_msg.pose.pose.orientation.z = car_quat[2]
                car_msg.pose.pose.orientation.w = car_quat[3]
                car_linear, car_angular = self.sim.get_car_velocity(
                    self.car_ids[car_name])
                car_msg.twist.twist.linear.x = car_linear[0]
                car_msg.twist.twist.linear.y = car_linear[1]
                car_msg.twist.twist.linear.z = car_linear[2]
                car_msg.twist.twist.angular.x = car_angular[0]
                car_msg.twist.twist.angular.y = car_angular[1]
                car_msg.twist.twist.angular.z = car_angular[2]
                self.car_odom_pubs[car_name].publish(car_msg)

        self.last_time = now
        self.reset_lock.release()

if __name__ == "__main__":
    Simulator()
